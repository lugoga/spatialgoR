<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Geospatial Technology and Spatial Analysis in R - 14&nbsp; Geometric operations with rasters</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ch10.html" rel="next">
<link href="./ch8.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ch9.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Geometric operations with rasters</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Geospatial Technology and Spatial Analysis in R</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch0.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Geospatial Technology in R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction <br> The R environment</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Vectors</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Time and Date</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch3Edition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Data types and data frame</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data frame Manipulation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch41.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Simple Features</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch5_matrix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Introduction to Matrices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch5_raster.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Introduction to Raster</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Raster Manipulation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch6_processing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Handling Rasters</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Vector layers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Geometric operations with vector layers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch9.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Geometric operations with rasters</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Combining rasters and vector layers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Processing spatio-temporal data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Spatial interpolation of point data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">High Frequency Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#aims" id="toc-aims" class="nav-link active" data-scroll-target="#aims"><span class="header-section-number">14.1</span> Aims</a></li>
  <li><a href="#mosaicking-rasters" id="toc-mosaicking-rasters" class="nav-link" data-scroll-target="#mosaicking-rasters"><span class="header-section-number">14.2</span> Mosaicking rasters</a></li>
  <li><a href="#raster-resampling" id="toc-raster-resampling" class="nav-link" data-scroll-target="#raster-resampling"><span class="header-section-number">14.3</span> Raster resampling</a>
  <ul class="collapse">
  <li><a href="#the-st_warp-function" id="toc-the-st_warp-function" class="nav-link" data-scroll-target="#the-st_warp-function"><span class="header-section-number">14.3.1</span> The <code>st_warp</code> function</a></li>
  <li><a href="#nearest-neighbor-resampling" id="toc-nearest-neighbor-resampling" class="nav-link" data-scroll-target="#nearest-neighbor-resampling"><span class="header-section-number">14.3.2</span> Nearest neighbor resampling</a></li>
  <li><a href="#bilinear-resampling" id="toc-bilinear-resampling" class="nav-link" data-scroll-target="#bilinear-resampling"><span class="header-section-number">14.3.3</span> Bilinear resampling</a></li>
  <li><a href="#average-resampling" id="toc-average-resampling" class="nav-link" data-scroll-target="#average-resampling"><span class="header-section-number">14.3.4</span> Average resampling</a></li>
  </ul></li>
  <li><a href="#raster-reprojection" id="toc-raster-reprojection" class="nav-link" data-scroll-target="#raster-reprojection"><span class="header-section-number">14.4</span> Raster reprojection</a></li>
  <li><a href="#focal-filters" id="toc-focal-filters" class="nav-link" data-scroll-target="#focal-filters"><span class="header-section-number">14.5</span> Focal filters</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">14.5.1</span> Introduction</a></li>
  <li><a href="#low-pass-filter" id="toc-low-pass-filter" class="nav-link" data-scroll-target="#low-pass-filter"><span class="header-section-number">14.5.2</span> Low pass filter</a></li>
  <li><a href="#maximum-filter" id="toc-maximum-filter" class="nav-link" data-scroll-target="#maximum-filter"><span class="header-section-number">14.5.3</span> Maximum filter</a></li>
  <li><a href="#topographic-slope" id="toc-topographic-slope" class="nav-link" data-scroll-target="#topographic-slope"><span class="header-section-number">14.5.4</span> Topographic slope</a></li>
  <li><a href="#topographic-aspect" id="toc-topographic-aspect" class="nav-link" data-scroll-target="#topographic-aspect"><span class="header-section-number">14.5.5</span> Topographic aspect</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Geometric operations with rasters</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="aims" class="level2" data-number="14.1">
<h2 data-number="14.1" class="anchored" data-anchor-id="aims"><span class="header-section-number">14.1</span> Aims</h2>
<p>Our aims in this chapter are:</p>
<ul>
<li><p>Make changes in the geometric component of rasters:</p>
<ul>
<li><p>Mosaicking</p></li>
<li><p>Resampling</p></li>
<li><p>Reprojecting</p></li>
</ul></li>
<li><p>Apply focal filters on a raster</p></li>
</ul>
<p>We will use the following R packages:</p>
<ul>
<li><p><code>stars</code></p></li>
<li><p><code>units</code></p></li>
</ul>
</section>
<section id="mosaicking-rasters" class="level2" data-number="14.2">
<h2 data-number="14.2" class="anchored" data-anchor-id="mosaicking-rasters"><span class="header-section-number">14.2</span> Mosaicking rasters</h2>
<p>In the next few examples, we will prepare a Digital Elevation Model (DEM) raster of Haifa, by mosaicking, subsetting and reprojecting (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-reprojection">9.3</a>).</p>
<p>We start with two 5°×5°5°×5° tiles of elevation data from the <a href="https://en.wikipedia.org/wiki/Shuttle_Radar_Topography_Mission">Shuttle Radar Topography Mission (SRTM)</a> dataset. The tiles are included as two <code>.tif</code> files in the sample files (Appendix <a href="https://geobgu.xyz/r-2021/files.html#files">A</a>):</p>
<pre><code>library(stars) dem1 = read_stars("srtm_43_06.tif") dem2 = read_stars("srtm_44_06.tif")</code></pre>
<p>As shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-tiles">9.1</a>, the tiles cover the area of northern Israel, including Haifa:</p>
<pre><code>plot(dem1, breaks = "equal", col = terrain.colors(10), axes = TRUE) plot(dem2, breaks = "equal", col = terrain.colors(10), axes = TRUE)</code></pre>
<p>Figure 9.1: Two elevation tiles from the SRTM dataset</p>
<p>Using the <code>st_bbox</code> and <code>dim</code> functions (Section <a href="https://geobgu.xyz/r-2021/matrices-and-rasters.html#dimensions-and-spatial-properties">5.3.8.3</a>), we can see that the two rasters indeed comprise two tiles of the same "large" dataset. First, we can see that the dimensions (number of rows and columns) of the two rasters are identical:</p>
<pre><code>dim(dem1) ##    x    y  ## 6000 6000 dim(dem2) ##    x    y  ## 6000 6000</code></pre>
<p>Second, we can see that their extents of the rasters are aligned. The y-axis (i.e., latitude) extent of the rasters is the same (<code>30</code>-<code>35</code>). The x-axis (i.e., longitude) extents of the rasters are side-by-side (<code>30</code>-<code>35</code> and <code>35</code>-<code>40</code>):</p>
<pre><code>st_bbox(dem1) ## xmin ymin xmax ymax  ##   30   30   35   35 st_bbox(dem2) ## xmin ymin xmax ymax  ##   35   30   40   35</code></pre>
<p>Rasters can be <strong>mosaicked</strong> using the <code>st_mosaic</code> function. The <code>st_mosaic</code> function accepts two or more <code>stars</code> objects—such as <code>dem1</code> and <code>dem2</code>—and returns a combined raster:</p>
<pre><code>dem = st_mosaic(dem1, dem2) names(dem) = "elevation"</code></pre>
<p>Note that the <code>st_moisaic</code> function can be used to combine rasters even if they are not aligned, such as in this example. In case the rasters are not aligned, resampling (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-resampling">9.2</a>) take place.</p>
<p>The mosaicked DEM is shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:merged-dem">9.2</a>:</p>
<pre><code>plot(dem, axes = TRUE, breaks = "equal", col = terrain.colors(10))</code></pre>
<p>Figure 9.2: Mosaicked raster</p>
<p>The extent of the resulting raster covers the extents of both inputs:</p>
<pre><code>st_bbox(dem) ## xmin ymin xmax ymax  ##   30   30   40   35</code></pre>
<p>For the next examples, we "crop" the <code>dem</code> raster according to an extent of 0.25°×0.25°0.25°×0.25° around Haifa (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:haifa-extent">9.3</a>).</p>
<p>Figure 9.3: An 0.25°×0.25°0.25°×0.25° rectangular extent</p>
<p>The <code>[</code> operator can be used to crop the raster (Section <a href="https://geobgu.xyz/r-2021/raster-processing.html#raster-subsetting">6.2</a>):</p>
<pre><code>dem = dem[, 5687:6287, 2348:2948]</code></pre>
<p>The result is shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:cropped-dem">9.4</a>:</p>
<pre><code>plot(dem, axes = TRUE, breaks = "equal", col = terrain.colors(10))</code></pre>
<p>Figure 9.4: Cropped raster</p>
<p>Note that in this example, we needed to know in advance the row and column indices of the extent we are interested in cropping. Later on (Section <a href="https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#masking-and-cropping-rasters">10.1</a>), we are going to learn how to crop a raster based on an existing vector layer, such as the bounding box of a buffer of 0.125°0.125° around a point layer representing the city of Haifa, which is a much more practical approach.</p>
</section>
<section id="raster-resampling" class="level2" data-number="14.3">
<h2 data-number="14.3" class="anchored" data-anchor-id="raster-resampling"><span class="header-section-number">14.3</span> Raster resampling</h2>
<section id="the-st_warp-function" class="level3" data-number="14.3.1">
<h3 data-number="14.3.1" class="anchored" data-anchor-id="the-st_warp-function"><span class="header-section-number">14.3.1</span> The <code>st_warp</code> function</h3>
<p>Raster <strong>resampling</strong> is the process of transferring raster values from the original grid to a different grid (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling">9.5</a>). Resampling is onften required for:</p>
<ul>
<li><p>Aligning several input rasters that come from different sources to the same grid, so that they can be subject to spatial operators such as raster algebra (Sections <a href="https://geobgu.xyz/r-2021/raster-processing.html#raster-algebra">6.4</a> and <a href="https://geobgu.xyz/r-2021/raster-processing.html#operating-on-each-pixel">6.6.1</a>)</p></li>
<li><p>Reducing the resolution of very detailed rasters, so that they are more convenient to work with in terms of processing time and memory use</p></li>
</ul>
<p>Figure 9.5: Raster resampling (<a href="https://www.safe.com/transformers/raster-resampler/" class="uri">https://www.safe.com/transformers/raster-resampler/</a>)</p>
<p>To demonstrate resampling, we will create a custom <code>stars</code> grid, using the same extent as the <code>dem</code> raster (<code>st_bbox(dem)</code>), but a coarser resolution. The new resolution is 0.002°0.002°, which is ~2.4 times the original resolution of 0.00083°0.00083°. The grid is created using <code>st_as_stars</code>:</p>
<pre><code>grid = st_as_stars(st_bbox(dem), dx = 0.002, dy = 0.002) grid ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##     values   ##  Min.   :0   ##  1st Qu.:0   ##  Median :0   ##  Mean   :0   ##  3rd Qu.:0   ##  Max.   :0   ## dimension(s): ##   from  to  offset  delta refsys point values x/y ## x    1 251 34.7383  0.002 WGS 84    NA   NULL [x] ## y    1 251 33.0442 -0.002 WGS 84    NA   NULL [y]</code></pre>
<p>Recall that we already used the <code>st_as_stars</code> function to convert a <code>matrix</code> to a <code>stars</code> raster (Section <a href="https://geobgu.xyz/r-2021/raster-processing.html#converting-matrix-to-raster">6.3.3</a>). What we do here is another mode of operation of the <code>st_as_stars</code> function, creating an <em>empty</em> raster given a <code>bbox</code> and the x- and y-axis resolutions <code>dx</code> and <code>dy</code>.</p>
<p>We can resample a raster using the <code>st_warp</code> function. The first two parameters of <code>st_warp</code> are:</p>
<ul>
<li><p>The raster to be resampled, where the values come from</p></li>
<li><p>The raster defining the new grid</p></li>
</ul>
<p>Here is the expression to resample the values of the <code>dem</code> raster into the new raster <code>grid</code>:</p>
<pre><code>dem1 = st_warp(dem, grid)</code></pre>
<blockquote class="blockquote">
<p>Which one of the rasters in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling">9.5</a> represents the role of <code>dem</code> and <code>grid</code>, in our case?</p>
</blockquote>
<blockquote class="blockquote">
<p>Try resampling <code>dem</code> to a different grid with an even coarser resulution, such as <code>0.02</code>, and plot the result</p>
</blockquote>
<p>The original DEM is shown along with the resampled one in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-resampled">9.6</a>.</p>
<pre><code>plot(dem, breaks = "equal", col = terrain.colors(10), main = "input (delta=0.0008)") plot(dem1, breaks = "equal", col = terrain.colors(10), main = "output (delta=0.002)")</code></pre>
<p>Figure 9.6: DEM resampled by a factor of 2.4, from 0.0008 (left) to 0.002 (right) resolution</p>
<p>When resampling, the computer needs to decide which pixel value(s) to transfer to each of the "new" pixels, defined by the new grid. There are several possible options, known as resampling algorithms or methods. In the next three sections, we are going to demonstrate three common options:</p>
<ul>
<li><p>Nearest neighbor resampling (the default) (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#nearest-neighbor-resampling">9.2.2</a>)</p></li>
<li><p>Bilinear resampling (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#bilinear-resampling">9.2.3</a>)</p></li>
<li><p>Average resampling (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#average-resampling">9.2.4</a>)</p></li>
</ul>
</section>
<section id="nearest-neighbor-resampling" class="level3" data-number="14.3.2">
<h3 data-number="14.3.2" class="anchored" data-anchor-id="nearest-neighbor-resampling"><span class="header-section-number">14.3.2</span> Nearest neighbor resampling</h3>
<p>The <code>st_warp</code> expression from Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#resampling">9.2.1</a> actually used the <strong>nearest neighbor</strong> resampling method (<code>method="near"</code>), which is the default:</p>
<pre><code>dem1 = st_warp(dem, grid, method = "near")</code></pre>
<p>To understand what actually happens in nearest neighbor resampling, let's take a look at a small part of the raster "before" and "after" images (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling-nearest">9.7</a>). If you look closely, you can see that the values of the original raster are passed to the resampled raster. What happens when there is more than one pixel of the original raster coinciding with a single pixel in the new grid? How can we decide which value is going to be passed? In nearest neighbor resampling, the new raster pixels get the value from the <em>nearest</em> pixel of the original raster. Note that some of the values may be "lost" this way, since they were not passed on to the new raster<sup><a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fn32">32</a></sup>.</p>
<p>Figure 9.7: Nearest neighbor resampling</p>
</section>
<section id="bilinear-resampling" class="level3" data-number="14.3.3">
<h3 data-number="14.3.3" class="anchored" data-anchor-id="bilinear-resampling"><span class="header-section-number">14.3.3</span> Bilinear resampling</h3>
<p><strong>Bilinear</strong> resampling is another resampling method. In bilinear resampling, each new raster cell gets a <em>weighted average</em> of <em>four</em> nearest cells from the input, rather than just one. Bilinear resampling is specified with <code>method="bilinear"</code> in <code>st_warp</code>. Note that <code>use_gdal=TRUE</code> needs to be specified when using any method other than <code>method="near"</code>, otherwise the <code>method</code> argument is ignored:</p>
<pre><code>dem1 = st_warp(dem, grid, method = "bilinear", use_gdal = TRUE)</code></pre>
<p>With bilinear resampling, the output raster is "smoothed," containing new values which are averages of (some of) the values in the original raster (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling-bilinear">9.8</a>).</p>
<p>Figure 9.8: Bilinear resampling</p>
</section>
<section id="average-resampling" class="level3" data-number="14.3.4">
<h3 data-number="14.3.4" class="anchored" data-anchor-id="average-resampling"><span class="header-section-number">14.3.4</span> Average resampling</h3>
<p>Another useful method is the <strong>average</strong> resampling method, where each new cell gets the weighted average of <em>all</em> overlapping input cells:</p>
<pre><code>dem1 = st_warp(dem, grid, method = "average", use_gdal = TRUE)</code></pre>
<p>The result of average resampling is shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling-average">9.9</a>:</p>
<p>Figure 9.9: Average resampling</p>
<p>In addition to <code>"near"</code>, <code>"bilinear"</code>, and <code>"average"</code>, the <code>st_warp</code> function supports other resampling <a href="https://github.com/r-spatial/stars/issues/109">methods</a>, including: <code>"cubic"</code>, <code>"cubicspline"</code>, <code>"lanczos"</code>, <code>"mode"</code>, <code>"max"</code>, <code>"min"</code>, <code>"med"</code>, <code>"q1"</code> and <code>"q3"</code>.</p>
<p>Bilinear resampling may be preferred when the result is primarily used for visualization, because the result appears smoother. Nearest neighbor resampling, however, is preferable when we are using the result for further analysis, because the original values are preserved. When the input raster is categorical, such as a raster with land cover classes <code>1</code>, <code>2</code>, <code>3</code>, etc., nearest neighbor resampling is the only valid resampling option, because averaging category IDs makes no sense.</p>
<blockquote class="blockquote">
<p>In what situations do you think the <code>"average"</code> resampling method is mostly appropriate, while <code>"near"</code> and <code>"bilinear"</code> are not?</p>
</blockquote>
</section>
</section>
<section id="raster-reprojection" class="level2" data-number="14.4">
<h2 data-number="14.4" class="anchored" data-anchor-id="raster-reprojection"><span class="header-section-number">14.4</span> Raster reprojection</h2>
<p>Raster <strong>reprojection</strong> is more complex than vector layer reprojection (Section <a href="https://geobgu.xyz/r-2021/vector-layers.html#vector-layer-reprojection">7.9.2</a>). In addition to transforming (pixel) coordinates, like in vector layer reprojection, raster reprojection requires a resampling step in order to "arrange" the transformed values back into a regular grid (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:reprojection-process">9.14</a>).</p>
<p>In terms of code, the <code>st_warp</code> function, which we used for resampling (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-resampling">9.2</a>), is used for raster reprojection too. The only difference is that, in raster reprojection, the "destination" grid is specified in a different CRS.</p>
<p>For example, the following expression reprojects the DEM of Haifa from WGS84 (<code>4326</code>) to UTM (<code>32636</code>), using the nearest neighbor resampling method. Note that, in this example, we are not passing a <code>stars</code> object with the destination grid. Instead, we are letting the function to automatically generate the new grid, only specifying the destination CRS (<code>crs=32636</code>) and resolution (<code>cellsize=90</code>):</p>
<pre><code>dem = st_warp(dem, crs = 32636, cellsize = 90)</code></pre>
<p>The original raster (in WGS84) and the reprojected one (in UTM) are shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-reprojected">9.10</a>.</p>
<p>Figure 9.10: Original (left, in WGS84) and reprojected (right, in UTM) <code>dem</code> raster</p>
<p>Note that the coordinate units in the reprojected raster (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-reprojected">9.10</a>) are no longer degrees, but meters. Also, the area contaning non-missing values is slightly rotated compared to the input, because the WGS84 and UTM systems are not parallel, at least in this particular location.</p>
<p>A zoomed-in view (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-reprojected-zoom">9.11</a>) of the original raster and the new grid demonstrates that the two are not parallel. Again, note that this time the new grid is in a different CRS, which is why the two grids are not parallel to each other (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling-nearest">9.7</a>–<a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:resampling-average">9.9</a>).</p>
<p>Figure 9.11: The reprojected raster grid (UTM, black) and the original raster grid (WGS84, in red), displayed in UTM</p>
<p>As another example, let's reproject the <code>MOD13A3_2000_2019.tif</code>, from its sinusoidal projection to a projection more suitable for the specific region, such as ITM (Table <a href="https://geobgu.xyz/r-2021/vector-layers.html#tab:projections-in-book">7.4</a>). First, let's import the raster from the GeoTIFF file:</p>
<pre><code>r = read_stars("MOD13A3_2000_2019.tif") names(r) = "NDVI"</code></pre>
<p>Then, we can reproject the raster using <code>st_warp</code>. This time we specify just the destination CRS (<code>crs=2039</code>), letting the function automatically determine the resolution:</p>
<pre><code>r_itm = st_warp(r, crs = 2039)</code></pre>
<p>The original and reprojected rasters are shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:modis-reprojection-complete">9.12</a>:</p>
<pre><code>plot(r[,,,1,drop=TRUE], key.pos = 4, axes = TRUE, col = hcl.colors(11, "Spectral"), main = "input (Sinusoidal)") plot(r_itm[,,,1,drop=TRUE], key.pos = 4, axes = TRUE, col = hcl.colors(11, "Spectral"), main = "output (ITM)")</code></pre>
<p>Figure 9.12: Reprojection of the MODIS NDVI raster from Sinusoidal (left) to ITM (right)</p>
<p>To see the process of reprojection more clearly, let's examine a small subset of the NDVI raster:</p>
<pre><code>u = r[, 100:105, 200:207, 2, drop = TRUE] u_itm = st_warp(u, crs = 2039)</code></pre>
<p>The original and reprojected raster subsets are shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:modis-reprojection-small">9.13</a>.</p>
<p>Figure 9.13: Reprojection of a small subset of the MODIS NDVI raster (left) to ITM (right)</p>
<p>What happens in the reprojection can be thought of as a two-step process (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:reprojection-process">9.14</a>). In the first step, the pixel outlines are reprojected as if they were polygons (Section <a href="https://geobgu.xyz/r-2021/vector-layers.html#vector-layer-reprojection">7.9.2</a>), which results in an <em>irregular</em> grid. The grid is then resampled (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-resampling">9.2</a>) to form a regular grid, so that it can be represented by a raster once again.</p>
<p>Figure 9.14: Reprojection process: the original raster (left), the reprojected raster cells as polygons (middle) and the resampled reprojected raster (right)</p>
</section>
<section id="focal-filters" class="level2" data-number="14.5">
<h2 data-number="14.5" class="anchored" data-anchor-id="focal-filters"><span class="header-section-number">14.5</span> Focal filters</h2>
<section id="introduction" class="level3" data-number="14.5.1">
<h3 data-number="14.5.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">14.5.1</span> Introduction</h3>
<p>So far, we only dealt with arithmetic operations that address the values of each per pixel in isolation from neighboring pixels, such as in raster algebra (Sections <a href="https://geobgu.xyz/r-2021/raster-processing.html#raster-algebra">6.4</a> and <a href="https://geobgu.xyz/r-2021/raster-processing.html#operating-on-each-pixel">6.6.1</a>). Another class of raster operations is where the calculation of each pixels depends on values of <em>neighboring cells</em>.</p>
<p>The most prominent example of a raster calculation based on neighboring cells is <strong>moving window</strong> calculations, also known as applying a <strong>focal filter</strong>. With a moving window calculation, raster values are transformed based on the values from a neighborhood surrounding each pixel. The functions applied on the neighborhood are varied, from simple functions such as <code>mean</code> for a low-pass filter (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#low-pass-filter">9.4.2</a>) to more complex functions, such as those used to calculate topographic slope and aspect (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#topographic-slope">9.4.4</a>–<a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#topographic-aspect">9.4.5</a>).</p>
<p>For example, a 3×33×3 <code>mean</code> filter applied on a raster results in a new raster, where the values are averages of 3×33×3 neighborhoods centered on that pixel. In Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:focal-filter">9.15</a>, the highlghted value in the output on the right (<code>18.7</code>) is the average of the highlighted 3×33×3 neighborhood of the input on the left:</p>
<pre><code>mean(c(27, 8, 22, 16, 21, 16, 6, 44, 8)) ## [1] 18.66667</code></pre>
<p>Figure 9.15: Focal filter (<a href="http://courses.washington.edu/gis250/lessons/raster_analysis1/index.html" class="uri">http://courses.washington.edu/gis250/lessons/raster_analysis1/index.html</a>)</p>
</section>
<section id="low-pass-filter" class="level3" data-number="14.5.2">
<h3 data-number="14.5.2" class="anchored" data-anchor-id="low-pass-filter"><span class="header-section-number">14.5.2</span> Low pass filter</h3>
<section id="what-is-a-low-pass-filter" class="level4" data-number="14.5.2.1">
<h4 data-number="14.5.2.1" class="anchored" data-anchor-id="what-is-a-low-pass-filter"><span class="header-section-number">14.5.2.1</span> What is a low pass filter?</h4>
<p>The purpose of the <code>mean</code>, or low-pass, filter (Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:focal-filter">9.15</a>) is to produce a <strong>smoothed</strong> image, where extreme values (possibly noise) are cacelled out. For example, the result of applying a 3×33×3 <code>mean</code> filter on a uniform image with one extreme value is shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:low-pass-filter">9.16</a>.</p>
<p>Figure 9.16: Low pass filter excample (<a href="http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-filter-works.htm" class="uri">http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-filter-works.htm</a>)</p>
<blockquote class="blockquote">
<p>How was the value of <code>5.4</code> obtained, in the result shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:low-pass-filter">9.16</a>?</p>
</blockquote>
<p>The <code>stars</code> package does not, at the moment, contain a function for focal filtering<sup><a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fn33">33</a></sup>. As an exercise, we are going to create our own function for focal filtering. For simplicity, we will restrict ourselves to the case where the focal "window" is 3×33×3 pixels—which is the most common case.</p>
<p>Our working plan is as follows:</p>
<ol type="1">
<li><p>Write a function named <code>get_neighbors</code> that accepts a position of the focal cell (row &amp; column) in a <code>matrix</code>, and returns the 9 values of its 3×33×3 pixel neighborhood</p></li>
<li><p>Write another function named <code>focal2</code> that accepts a two-dimensional <code>stars</code> object and a function <code>fun</code>, iterates over the cells and applies <code>fun</code> on all 3×33×3 pixel neighborhoods extracted using <code>get_heighbors</code></p></li>
</ol>
</section>
<section id="the-get_neighbors-function" class="level4" data-number="14.5.2.2">
<h4 data-number="14.5.2.2" class="anchored" data-anchor-id="the-get_neighbors-function"><span class="header-section-number">14.5.2.2</span> The <code>get_neighbors</code> function</h4>
<p>We start with a function that accepts a position (row &amp; column) in a <code>matrix</code> and returns a numeric vector with the 3×33×3 neighborhood, hereby named <code>get_neighbors</code>. The function accepts a matrix <code>m</code> and a position <code>pos</code>. The <code>pos</code> argument is a vector of length two, of the form <code>c(row,column)</code>. The function extracts the 9 values in the respective 3×33×3 neighborhood and returns them as a vector of length 9:</p>
<pre><code>get_neighbors = function(m, pos) {   i = (pos[1]-1):(pos[1]+1)   j = (pos[2]-1):(pos[2]+1)   as.vector(t(m[i, j])) }</code></pre>
<p>For example, suppose we have a 5×55×5 matrix <code>m</code>:</p>
<pre><code>m = matrix(1:25, ncol = 5, nrow = 5) m ##      [,1] [,2] [,3] [,4] [,5] ## [1,]    1    6   11   16   21 ## [2,]    2    7   12   17   22 ## [3,]    3    8   13   18   23 ## [4,]    4    9   14   19   24 ## [5,]    5   10   15   20   25</code></pre>
<p>Using <code>get_neighbors</code>, we can get the values of just about any 3×33×3 neighborhood except for the outermost rows and columns (see below). For example, the following expression returns the values of the neighborhood centered on row <code>3</code>, column <code>4</code>:</p>
<pre><code>get_neighbors(m, c(3, 4)) ## [1] 12 17 22 13 18 23 14 19 24</code></pre>
<p>How does the <code>get_neighbors</code> function work? The function first calculates the required range of rows and columns:</p>
<pre><code>pos = c(3, 4)</code></pre>
<pre><code>i = (pos[1]-1):(pos[1]+1)  # Rows i ## [1] 2 3 4</code></pre>
<pre><code>j = (pos[2]-1):(pos[2]+1)  # Columns j ## [1] 3 4 5</code></pre>
<p>Then, the function extracts the corresponding <code>matrix</code> subset:</p>
<pre><code>m[i, j] ##      [,1] [,2] [,3] ## [1,]   12   17   22 ## [2,]   13   18   23 ## [3,]   14   19   24</code></pre>
<p>transposes it:</p>
<pre><code>t(m[i, j]) ##      [,1] [,2] [,3] ## [1,]   12   13   14 ## [2,]   17   18   19 ## [3,]   22   23   24</code></pre>
<p>and converts to a vector:</p>
<pre><code>as.vector(t(m[i, j])) ## [1] 12 17 22 13 18 23 14 19 24</code></pre>
<p>Transposing is necessary so that the <code>matrix</code> values are returned <em>by row</em>, rather than the default <em>by column</em> (Section <a href="https://geobgu.xyz/r-2021/matrices-and-rasters.html#matrix-to-vector">5.1.4.1</a>).</p>
<p>Note that out function is not designed to operate on the matrix edges, where the 3×33×3 neighborhood is incomplete. For example, the following expression produces an error:</p>
<pre><code>get_neighbors(m, c(1, 5)) ## Error in m[i, j]: subscript out of bounds</code></pre>
</section>
<section id="the-focal2-function" class="level4" data-number="14.5.2.3">
<h4 data-number="14.5.2.3" class="anchored" data-anchor-id="the-focal2-function"><span class="header-section-number">14.5.2.3</span> The <code>focal2</code> function</h4>
<p>Now, let's see how we can use the <code>get_neighbors</code> function to apply a focal filter on a raster. We will use the <code>dem.tif</code> small DEM for demonstration:</p>
<pre><code>x = read_stars("dem.tif")</code></pre>
<p>First, we create a copy of the raster, named <code>template</code>. The <code>template</code> raster will be used as a "template" when converting the filtered <code>matrix</code> back to a <code>stars</code> object:</p>
<pre><code>template = x</code></pre>
<p>Next, we extract the raster values as a <code>matrix</code>:</p>
<pre><code>input = t(template[[1]])</code></pre>
<p>Note that the function relies on the fact that the <code>stars</code> object has just two dimensions (x and y), in which case <code>input</code> is going to be a <code>matrix</code>. The <code>matrix</code> is transposed, using <code>t</code>, to maintain the right orientation of the values matrix (Figure <a href="https://geobgu.xyz/r-2021/raster-processing.html#fig:effect-transpose-delta">6.11</a>). This is important when using functions that distinguish between the north-south and east-west directions, topographic aspect (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#topographic-aspect">9.4.5</a>).</p>
<p>Next, we create <em>another</em> <code>matrix</code> to hold the output values. The values are initially set to <code>NA</code>:</p>
<pre><code>output = matrix(NA, nrow = nrow(input), ncol = ncol(input))</code></pre>
<p>Now comes the actual computation. We are using two <code>for</code> loops to go over all raster cells, excluding the first and last rows and columns. For each cell, we:</p>
<ul>
<li><p>extract the 3×33×3 neighborhood <code>[i,j]</code>,</p></li>
<li><p>apply a function—such as <code>mean</code>, in this case—on the vector of extracted values, and</p></li>
<li><p>place the result into the corresponding cell <code>[i,j]</code> in the output.</p></li>
</ul>
<p>The complete code of the <code>for</code> loops is as follows:</p>
<pre><code>for(i in 2:(nrow(input) - 1)) {   for(j in 2:(ncol(input) - 1)) {     v = get_neighbors(input, c(i, j))     output[i, j] = mean(v, na.rm = TRUE)   } }</code></pre>
<p>Note that the function starts at row <code>i=2</code> and ends at row <code>i=nrow(input)-1</code>. Similarly, it starts at column <code>j=2</code> and ends at <code>j=ncol(input)-1</code>.</p>
<p>In the end, when both <code>for</code> loops have been completed, the <code>output</code> matrix contains the new, filtered, raster values. What is left to be done is to put the <code>matrix</code> of new values into the template, to get back a <code>stars</code> object. We are using <code>t</code> once again, to transform the <code>matrix</code> back into the "stars" arrangement (Figure <a href="https://geobgu.xyz/r-2021/raster-processing.html#fig:effect-transpose-delta">6.11</a>):</p>
<pre><code>template[[1]] = t(output)</code></pre>
<p>The original image (<code>x</code>) and the filtered image (<code>template</code>) are shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-low-pass">9.17</a>. The figure highlights one 3×33×3 neighborhood in the input, and the corresponding average of that neighborhood in the output<sup><a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fn34">34</a></sup>.</p>
<pre><code>col = terrain.colors(5) plot(x, text_values = TRUE, col = col, key.pos = 4, reset = FALSE, main = "input") plot(st_geometry(st_as_sf(x, na.rm = FALSE)), border = "grey", add = TRUE) plot(st_geometry(st_as_sf(x[,4:6,6:8])), lwd = 2, add = TRUE) plot(round(template, 1), text_values = TRUE, col = col, key.pos = 4, reset = FALSE, main = "output") plot(st_geometry(st_as_sf(template, na.rm = FALSE)), border = "grey", add = TRUE) plot(st_geometry(st_as_sf(template[,5,7])), lwd = 2, add = TRUE)</code></pre>
<p>Figure 9.17: Focal filter with the <code>mean</code> function (left: input, right: result)</p>
<blockquote class="blockquote">
<p>Why do the outermost rows and columns in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-low-pass">9.17</a> appear empty? Which value do these pixels contain, and where did it come from?</p>
</blockquote>
<p>Let's manually check the calculation of the 3×33×3 neighborhood highlighted in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-low-pass">9.17</a>:</p>
<pre><code>t(x[[1]][4:6,6:8]) ##      [,1] [,2] [,3] ## [1,]  146    6    6 ## [2,]  340  163   13 ## [3,]  383  448  152</code></pre>
<pre><code>mean(t(x[[1]][4:6,6:8])) ## [1] 184.1111</code></pre>
<blockquote class="blockquote">
<p>Why do you think we got <code>NaN</code> values in some of the cells? Can you simulate the situation to see how an <code>NaN</code> values is produced? What can we do to get <code>NA</code>, instead, in those pixes that get <code>NaN</code>?</p>
</blockquote>
<p>Wrapping up out code in a function, called <code>focal2</code>, can be done as follows. The input raster and the function are replaced with parameters named <code>r</code> and <code>fun</code>, respectively:</p>
<pre><code>focal2 = function(r, fun) {   template = r   input = t(template[[1]])   output = matrix(NA, nrow = nrow(input), ncol = ncol(input))   for(i in 2:(nrow(input) - 1)) {     for(j in 2:(ncol(input) - 1)) {       v = get_neighbors(input, c(i, j))       output[i, j] = fun(v)     }   }   template[[1]] = t(output)   return(template) }</code></pre>
<p>How can we pass additional parameters to the function we use, such as <code>na.rm=TRUE</code> for <code>mean</code>? The special dots <code>...</code> argument is used for that. Now, any additional argument(s) passed to <code>focal2</code> (such as <code>na.rm=TRUE</code>) will be passed on as additional argument(s) to <code>fun</code>:</p>
<pre><code>focal2 = function(r, fun, ...) {   template = r   input = t(template[[1]])   output = matrix(NA, nrow = nrow(input), ncol = ncol(input))   for(i in 2:(nrow(input) - 1)) {     for(j in 2:(ncol(input) - 1)) {       v = get_neighbors(input, c(i, j))       output[i, j] = fun(v, ...)     }   }   template[[1]] = t(output)   return(template) }</code></pre>
<p>Now that we have a custom focal filter function <code>focal2</code>, let's try to apply a different filter, such as a <em>maximum</em> filter:</p>
<pre><code>x_max = focal2(x, max, na.rm = TRUE) ## Warning in fun(v, ...): no non-missing arguments to max; returning -Inf  ## Warning in fun(v, ...): no non-missing arguments to max; returning -Inf</code></pre>
<p>The reason for the warnings produced by the above expression is that <code>max</code> applied on an empty vector gives <code>-Inf</code>.</p>
<pre><code>t(x_max[[1]]) ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] ##  [1,]   NA   NA   NA   NA   NA   NA   NA ##  [2,]   NA -Inf -Inf    6    9    9   NA ##  [3,]   NA   61   61    9   10   16   NA ##  [4,]   NA  132  132  132   11   27   NA ##  [5,]   NA  254  254  254  146   27   NA ##  [6,]   NA  254  340  340  340  163   NA ##  [7,]   NA  254  383  448  448  448   NA ##  [8,]   NA  253  383  448  448  448   NA ##  [9,]   NA  253  383  448  448  448   NA ## [10,]   NA   NA   NA   NA   NA   NA   NA</code></pre>
<p>To get <code>NA</code> instead, we can use a slightly more complex function that first checks if particular neighborhood contains any non-<code>NA</code> values, any only then applies <code>max</code>:</p>
<pre><code>f = function(x) if(all(is.na(x))) NA else max(x, na.rm = TRUE) x_max = focal2(x, f)</code></pre>
<p>Recall that we used the same principle when applying the <code>min</code> and <code>max</code> functions with <code>st_apply</code> (Section <a href="https://geobgu.xyz/r-2021/raster-processing.html#pixel-ranges">6.6.1.4</a>).</p>
<p>The resulting raster <code>x_max</code> is shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-low-pass-na-rm">9.18</a>. Indeed, every pixel value in the output raster is the maximal value among the values in its 3×33×3 neighborhood:</p>
<pre><code>col = terrain.colors(10) plot(x, text_values = TRUE, breaks = "equal", col = col, key.pos = 4, reset = FALSE, main = "input") plot(st_geometry(st_as_sf(x, na.rm = FALSE)), border = "grey", add = TRUE) plot(st_geometry(st_as_sf(x[,4:6,6:8])), lwd = 2, add = TRUE) plot(x_max, breaks = "equal", text_values = TRUE, col = col, key.pos = 4, reset = FALSE, main = "output") plot(st_geometry(st_as_sf(x_max, na.rm = FALSE)), border = "grey", add = TRUE) plot(st_geometry(st_as_sf(x_max[,5,7])), lwd = 2, add = TRUE)</code></pre>
<p>Figure 9.18: Focal filter with the <code>max</code> function (left: input, right: result)</p>
<p>Let's try the <code>focal2</code> function on another, bigger raster. For example, we can apply a low pass (i.e., <code>mean</code>) filter on the first layer of the MODIS NDVI raster, as follows:</p>
<pre><code>r_itm1 = r_itm[,,,1,drop=TRUE] r_itm1_mean = focal2(r_itm1, mean, na.rm = TRUE)</code></pre>
<p>The original image and the filtered result are shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:modis-ndvi-lowpass">9.19</a>:</p>
<pre><code>plot(r_itm1, col = hcl.colors(11, "Spectral"), main = "input") plot(r_itm1_mean, col = hcl.colors(11, "Spectral"), main = "output")</code></pre>
<p>Figure 9.19: Low pass filter result</p>
<blockquote class="blockquote">
<p>Why are there <code>NA</code> areas in the raster, even though we used <code>na.rm=TRUE</code>?</p>
</blockquote>
</section>
</section>
<section id="maximum-filter" class="level3" data-number="14.5.3">
<h3 data-number="14.5.3" class="anchored" data-anchor-id="maximum-filter"><span class="header-section-number">14.5.3</span> Maximum filter</h3>
<p>For another example, let's reconstruct the <code>l_rec</code> raster (Section <a href="https://geobgu.xyz/r-2021/raster-processing.html#classification">6.5</a>):</p>
<pre><code>l = read_stars("landsat_04_10_2000.tif") red = l[,,,3, drop = TRUE] nir = l[,,,4, drop = TRUE] ndvi = (nir - red) / (nir + red) names(ndvi) = "NDVI" l_rec = ndvi l_rec[l_rec &lt; 0.2] = 0 l_rec[l_rec &gt;= 0.2] = 1</code></pre>
<p>Given a raster with <code>0</code> and <code>1</code> values, such as <code>l_rec</code>, we may want to convert all <code>0</code> cells neighboring to a <code>1</code> cell to become <code>1</code>. That way, for instance, the areas of the planted forests we see in the center of the image will be come more continuous, which will make it easier to transform those areas into polygons (Section <a href="https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#segmentation">10.3.2</a>). This can be achieved with a focal filter and the <code>max</code> function:</p>
<pre><code>l_rec_focal = focal2(l_rec, max)</code></pre>
<p>The original raster and the filtered result are shown in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:ndvi-max-filter">9.20</a>:</p>
<pre><code>plot(l_rec, col = c("grey90", "darkgreen"), main = "input") plot(l_rec_focal, col = c("grey90", "darkgreen"), main = "output")</code></pre>
<p>Figure 9.20: "Buffering" <code>1</code> values in a raster with <code>0</code>s and <code>1</code>s, using a focal filter with <code>max</code></p>
</section>
<section id="topographic-slope" class="level3" data-number="14.5.4">
<h3 data-number="14.5.4" class="anchored" data-anchor-id="topographic-slope"><span class="header-section-number">14.5.4</span> Topographic slope</h3>
<p>So far we saw examples where the focal function is a simple built-in one, such as <code>mean</code> or <code>max</code>. In some cases, it is required to use a more complex function. For example, topographic indices such as slope and aspect employ complex functions where direction matters: each of the nine pixels in the 3×33×3 neignborhood is treated differently. For example, to calculate topographic slope based on elevation values in a 3×33×3 neignborhood, the following function can be used. Note that the slope calulation also depends on raster <em>resolution</em>, which is passed as an additional parameter named <code>res</code>:</p>
<pre><code>slope = function(x, res) {   dzdx = ((x[3] + 2*x[6] + x[9]) - (x[1] + 2*x[4] + x[7])) / (8 * res)   dzdy = ((x[7] + 2*x[8] + x[9]) - (x[1] + 2*x[2] + x[3])) / (8 * res)   atan(sqrt(dzdx^2 + dzdy^2)) * (180 / pi) }</code></pre>
<p>We will not go into details on how the function works. You may refer to the <a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-slope-works.htm"><em>How slope works</em></a> article in the ArcGIS documentation for an explanation.</p>
<p>For example:</p>
<pre><code>x = c(50, 45, 50, 30, 30, 30, 8, 10, 10) res = 5 slope(x, res)  # 75.25762 ## [1] 75.25766</code></pre>
<p>The <code>slope</code> function can be passed to <code>focal2</code> to apply the slope calculation on the entire <code>dem</code> raster:</p>
<pre><code>dem_slope = focal2(dem, slope, res = st_dimensions(dem)$x$delta) names(dem_slope) = "slope"</code></pre>
<p>It is also convenient to set raster units with <code>set_units</code> (Section <a href="https://geobgu.xyz/r-2021/geometric-operations-with-vector-layers.html#area">8.3.2.2</a>). The units of slope are decimal degrees (<code>°</code>):</p>
<pre><code>library(units) dem_slope[[1]] = set_units(dem_slope[[1]], "degree")</code></pre>
<p>The resulting topographic slope raster is shown in the left panel in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-slope-aspect">9.21</a>.</p>
</section>
<section id="topographic-aspect" class="level3" data-number="14.5.5">
<h3 data-number="14.5.5" class="anchored" data-anchor-id="topographic-aspect"><span class="header-section-number">14.5.5</span> Topographic aspect</h3>
<p>Another function, as shown below, can be used to calculate topographic aspect:</p>
<pre><code>aspect = function(x, res) {   dzdx = ((x[3] + 2*x[6] + x[9]) - (x[1] + 2*x[4] + x[7])) / 8   dzdy = ((x[7] + 2*x[8] + x[9]) - (x[1] + 2*x[2] + x[3])) / 8   a = (180 / pi) * atan2(dzdy, -dzdx)   if(is.na(a)) return(NA)   if (a &lt; 0) a = 90 - a else      if (a &gt; 90) a = 360 - a + 90 else        a = 90 - a   return(a) }</code></pre>
<p>For details on how the function works, see the <a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-aspect-works.htm"><em>How aspect works</em></a> article in the ArcGIS documentation.</p>
<p>For example:</p>
<pre><code>x = c(101, 92, 85, 101, 92, 85, 101, 91, 84) aspect(x)  # 92.64 ## [1] 92.64255</code></pre>
<p>Again, the <code>aspect</code> function can be passed to <code>focal2</code> to apply it on the entire raster:</p>
<pre><code>dem_aspect = focal2(dem, aspect) names(dem_aspect) = "aspect" dem_aspect[[1]] = set_units(dem_aspect[[1]], "degree")</code></pre>
<p>The resulting topographic aspect raster is shown in the right panel in Figure <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#fig:dem-slope-aspect">9.21</a>:</p>
<pre><code>plot(dem_slope, breaks = "equal", col = rev(hcl.colors(11, "Spectral"))) plot(dem_aspect, breaks = "equal", col = hcl.colors(11, "Spectral"))</code></pre>
<p>Figure 9.21: Topographic slope (left) and topographic aspect (right)</p>
<p>Note that our custom <code>focal2</code>+<code>get_neighbors</code> functions are quite minimal, and can be improved in several ways:</p>
<ul>
<li><p>Being able to set neighbor sizes other than 3×33×3</p></li>
<li><p>Dealing with the first/last rows and and columns (see Section <a href="https://geobgu.xyz/r-2021/exercise-05.html#exercise-05">G</a>)</p></li>
<li><p>Dealing with rasters that have more than two dimensions (separate filter per dimension? a three-dimensional filter?)</p></li>
<li><p>Making the calculation more efficient (e.g., using <a href="https://cran.r-project.org/package=Rcpp">C/C++ code</a> inside R or using <a href="https://cran.r-project.org/web/views/HighPerformanceComputing.html">parallel</a> computation)</p></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ch8.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Geometric operations with vector layers</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ch10.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Combining rasters and vector layers</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>