<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Geospatial Technology and Spatial Analysis in R - 17&nbsp; Spatial interpolation of point data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ch13.html" rel="next">
<link href="./ch11.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ch12.html"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Spatial interpolation of point data</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Geospatial Technology and Spatial Analysis in R</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch0.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Geospatial Technology in R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction <br> The R environment</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Vectors</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Time and Date</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch3Edition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Data types and data frame</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data frame Manipulation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch41.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Simple Features</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch5_matrix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Introduction to Matrices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch5_raster.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Introduction to Raster</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Raster Manipulation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch6_processing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Handling Rasters</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Vector layers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Geometric operations with vector layers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Geometric operations with rasters</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Combining rasters and vector layers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Processing spatio-temporal data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch12.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Spatial interpolation of point data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">High Frequency Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#aims" id="toc-aims" class="nav-link active" data-scroll-target="#aims"><span class="header-section-number">17.1</span> Aims</a></li>
  <li><a href="#what-is-spatial-interpolation" id="toc-what-is-spatial-interpolation" class="nav-link" data-scroll-target="#what-is-spatial-interpolation"><span class="header-section-number">17.2</span> What is spatial interpolation?</a>
  <ul class="collapse">
  <li><a href="#interpolation-models" id="toc-interpolation-models" class="nav-link" data-scroll-target="#interpolation-models"><span class="header-section-number">17.2.1</span> Interpolation models</a></li>
  <li><a href="#the-weighted-average-principle" id="toc-the-weighted-average-principle" class="nav-link" data-scroll-target="#the-weighted-average-principle"><span class="header-section-number">17.2.2</span> 12.1.2 The weighted average principle</a></li>
  </ul></li>
  <li><a href="#inverse-distance-weighted-interpolation" id="toc-inverse-distance-weighted-interpolation" class="nav-link" data-scroll-target="#inverse-distance-weighted-interpolation"><span class="header-section-number">17.3</span> Inverse Distance Weighted interpolation</a>
  <ul class="collapse">
  <li><a href="#the-gstat-object" id="toc-the-gstat-object" class="nav-link" data-scroll-target="#the-gstat-object"><span class="header-section-number">17.3.1</span> The <code>gstat</code> object</a></li>
  <li><a href="#working-with-formula-objects" id="toc-working-with-formula-objects" class="nav-link" data-scroll-target="#working-with-formula-objects"><span class="header-section-number">17.3.2</span> Working with <code>formula</code> objects</a></li>
  <li><a href="#making-predictions" id="toc-making-predictions" class="nav-link" data-scroll-target="#making-predictions"><span class="header-section-number">17.3.3</span> Making predictions</a></li>
  </ul></li>
  <li><a href="#ordinary-kriging" id="toc-ordinary-kriging" class="nav-link" data-scroll-target="#ordinary-kriging"><span class="header-section-number">17.4</span> Ordinary Kriging</a>
  <ul class="collapse">
  <li><a href="#annual-rainfall-example" id="toc-annual-rainfall-example" class="nav-link" data-scroll-target="#annual-rainfall-example"><span class="header-section-number">17.4.1</span> Annual rainfall example</a></li>
  <li><a href="#elevation-example" id="toc-elevation-example" class="nav-link" data-scroll-target="#elevation-example"><span class="header-section-number">17.4.2</span> Elevation example</a></li>
  <li><a href="#monthly-rainfall-example" id="toc-monthly-rainfall-example" class="nav-link" data-scroll-target="#monthly-rainfall-example"><span class="header-section-number">17.4.3</span> Monthly rainfall example</a></li>
  </ul></li>
  <li><a href="#universal-kriging" id="toc-universal-kriging" class="nav-link" data-scroll-target="#universal-kriging"><span class="header-section-number">17.5</span> Universal Kriging</a></li>
  <li><a href="#cross-validation" id="toc-cross-validation" class="nav-link" data-scroll-target="#cross-validation"><span class="header-section-number">17.6</span> Cross-validation</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Spatial interpolation of point data</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="aims" class="level2" data-number="17.1">
<h2 data-number="17.1" class="anchored" data-anchor-id="aims"><span class="header-section-number">17.1</span> Aims</h2>
<p>Our aims in this chapter are:</p>
<ul>
<li><p>Calculate an empirical variogram</p></li>
<li><p>Fit a variogram model</p></li>
<li><p>Interpolate using three methods:</p>
<ul>
<li><p>Inverse Distance Weighted (IDW) interpolation</p></li>
<li><p>Ordinary Kriging (OK)</p></li>
<li><p>Universal Kriging (UK)</p></li>
</ul></li>
<li><p>Evaluate interpolation accuracy using Leave-One-Out Cross Validation</p></li>
</ul>
<p>We will use the following R packages:</p>
<ul>
<li><p><code>sf</code></p></li>
<li><p><code>stars</code></p></li>
<li><p><code>gstat</code></p></li>
<li><p><code>automap</code></p></li>
</ul>
</section>
<section id="what-is-spatial-interpolation" class="level2" data-number="17.2">
<h2 data-number="17.2" class="anchored" data-anchor-id="what-is-spatial-interpolation"><span class="header-section-number">17.2</span> What is spatial interpolation?</h2>
<section id="interpolation-models" class="level3" data-number="17.2.1">
<h3 data-number="17.2.1" class="anchored" data-anchor-id="interpolation-models"><span class="header-section-number">17.2.1</span> Interpolation models</h3>
<p><strong>Spatial interpolation</strong> is the prediction of a given phenomenon in unmeasured locations (Figures <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:interpolation1">12.1</a>–<a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:interpolation2">12.2</a>). For that, we need a spatial interpolation <strong>model</strong>—a set of procedures to calculate <strong>predicted</strong> values of the variable of interest, given <strong>calibration</strong> data.</p>
<p>Figure 12.1: Spatial interpolation (Input elevation point data, Interpolated elevation surface) (<a href="http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/understanding-interpolation-analysis.htm" class="uri">http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/understanding-interpolation-analysis.htm</a>)</p>
<p>Figure 12.2: Spatial interpolation (Point locations of ozone monitoring stations, Interpolated prediction surface) (<a href="http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/understanding-interpolation-analysis.htm" class="uri">http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/understanding-interpolation-analysis.htm</a>)</p>
<p>Calibrarion data usually include:</p>
<ul>
<li><p><strong>Field measurements</strong>—available for a limited number of locations, for example: rainfall data from meteorological stations</p></li>
<li><p><strong>Covariates</strong>—available for each and every location within the area of interest, for example: elevation from a DEM</p></li>
</ul>
<p>Spatial interpolation models can be divided into two general categories:</p>
<ul>
<li><p><strong>Deterministic models</strong>—Models using arbitrary parameter values, for example: IDW</p></li>
<li><p><strong>Statistical models</strong>—Models using parameters chosen objectively based on the data, for example: Kriging</p></li>
</ul>
<p>Keep in mind that data <em>structure</em> does not imply <em>meaning</em>. It is technically possible to interpolate any numeric variable measured in a set of points, however it does not always make sense to do so. For example, it does not make sense to spatially interpolate point data when they refer to a localized phenomenon, such as amount of emissions per power plant (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:point-vs-continuous1">12.3</a>).</p>
<p>Figure 12.3: CO2��2 emissions from power plants: a localized phenomenon (<a href="https://edzer.github.io/UseR2016/" class="uri">https://edzer.github.io/UseR2016/</a>)</p>
<p>Converesly, it does not make sense to sum up point measurements of a continuous phenomenon (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:point-vs-continuous2">12.4</a>).</p>
<p>Figure 12.4: PM10��10 measurements: a continuous phenomenon (<a href="https://edzer.github.io/UseR2016/" class="uri">https://edzer.github.io/UseR2016/</a>)</p>
</section>
<section id="the-weighted-average-principle" class="level3" data-number="17.2.2">
<h3 data-number="17.2.2" class="anchored" data-anchor-id="the-weighted-average-principle"><span class="header-section-number">17.2.2</span> 12.1.2 The weighted average principle</h3>
<p>Many of the commonly used interpolation methods, including the ones we learn about in this Chapter (Nearest Neighbor, IDW, Kriging), are based on the same principle, where a predicted value is a <strong>weighted average</strong> of neighboring points. Weight are usually inveresely related to distance, i.e., as distance increases the weight (importance) of the point decreases. The predicted value for a particular point is calculated as a weighted average of measured values in other points (Equation <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:weighted-average">(12.1)</a>):</p>
<p>[^Z(s0)=∑ni=1w(si)Z(si)∑ni=1w(si)(12.1)(12.1)�^(�0)=∑�=1��(��)�(��)∑�=1��(��)]{.underline}</p>
<p>where:</p>
<ul>
<li><p>^Z(s0)�^(�0) is the predicted value at location s0�0</p></li>
<li><p>w(si)�(��) is the weight of measured point i�</p></li>
<li><p>Z(si)�(��) is the value of measured point i�</p></li>
</ul>
<p>The weight w(si)�(��) of each measured point is a function of distance (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:distance-observed-predicted">12.5</a>) from the predicted point.</p>
<p>Figure 12.5: Distances between predicted point and all measured points (<a href="http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-kriging-works.htm" class="uri">http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-kriging-works.htm</a>)</p>
<p>In IDW, the weight is the inverse of distance to the power of p� (Equation <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:idw">(12.2)</a>):</p>
<p><u>w(si)=1d(s0,si)p(12.2)(12.2)�(��)=1�(�0,��)�</u></p>
<p>where:</p>
<ul>
<li><p>w(si)�(��) is the weight of measured point i�</p></li>
<li><p>d(s0,si)�(�0,��) is the distance between predicted point s0�0 and measured point si��</p></li>
</ul>
<p>The default value for p� is usually p=2�=2 (Equation <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:idw2">(12.3)</a>):</p>
<p><u>w(si)=1d(s0,si)2(12.3)(12.3)�(��)=1�(�0,��)2</u></p>
<p>The p� parameter basically determines how steeply does weight increase with proximity. As a result, p� determines whether weights are more or less equally distributed among neighbors (low p�) or whether one point (the nearest) has overwhelmingly high weight and thus the predicted value will be strongly influenced by that point (high p�). In other words, when p� approaches zero, the predicted result will approach a uniform surface which is just an average of all measured points. When p� approaches infinity, the predicted result will approach nearest <strong>neighbor interpolation</strong>, which is the simplest <em>spatial</em> interpolation method there is: every predicted point gets the value of the nearest measured point (Figures <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:idw-p">12.6</a>–<a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:nearest-neighbor">12.7</a>).</p>
<p>Figure 12.6: Spatial interpolation of annual rainfall using IDW with p=0.25�=0.25, p=2�=2 and p=16�=16</p>
<p>Figure 12.7: Nearest Neighbor interpolation (left) and Voronoi polygons (right)</p>
<p>In Kriging, the weight is a particular function of distance known as the <strong>variogram model</strong> (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram-models">12.8</a>). The variogram model is fitted to characterize the autocorrelation structure in the measured data, based on the <strong>empirical variogram</strong>.</p>
<p>Figure 12.8: Variogram models: spherical (left) and exponential (right) (<a href="http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-kriging-works.htm" class="uri">http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-kriging-works.htm</a>)</p>
<p>There are two frequently used kriging methods: Ordinary Kriging (OK) and Universal Kriging (UK). Adding up the Inverse Distance Weighted (IDW) interpolation, we now mentioned three interpolation methods. We are going to cover those three methods (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:idw-ok-uk">12.9</a>), mostly from the practical point of view, in the next three sections (Sections <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#inverse-distance-weighted-interpolation">12.2</a>–<a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#universal-kriging">12.4</a>).</p>
<p>Figure 12.9: Spatial interpolation of annual rainfall using IDW, OK and UK</p>
<p>For the examples, we will load the <code>rainfall.csv</code> file (Section <a href="https://geobgu.xyz/r-2021/tables-conditionals-and-loops.html#example-the-rainfall-csv-structure">4.4.3</a>), calculate the <code>annual</code> column (Section <a href="https://geobgu.xyz/r-2021/tables-conditionals-and-loops.html#the-apply-function">4.5</a>) and convert it to a point layer (Section <a href="https://geobgu.xyz/r-2021/vector-layers.html#creating-point-layer-from-table">7.4</a>):</p>
<pre><code>library(sf) rainfall = read.csv("rainfall.csv") rainfall = st_as_sf(rainfall, coords = c("x_utm", "y_utm"), crs = 32636) m = c("sep", "oct", "nov", "dec", "jan", "feb", "mar", "apr", "may") rainfall$annual = apply(st_drop_geometry(rainfall[, m]), 1, sum)</code></pre>
<p>We will also use a 1×11×1 km2��2 DEM raster of the area of interest (Sections <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#mosaicking-rasters">9.1</a>, <a href="https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-reprojection">9.3</a> and <a href="https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#masking-and-cropping-rasters">10.1</a>):</p>
<pre><code>library(stars) dem1 = read_stars("srtm_43_06.tif") dem2 = read_stars("srtm_44_06.tif") dem = st_mosaic(dem1, dem2) borders = st_read("israel_borders.shp") grid = st_as_sfc(st_bbox(borders)) grid = st_as_stars(grid, dx = 1000, dy = 1000) dem = st_warp(src = dem, grid, method = "average", use_gdal = TRUE) dem = dem[borders] names(dem) = "elev_1km"</code></pre>
<p>Finally, we subset the <code>dem</code> to include only the area to the north of 31 degrees latitude, where meteorological station density is relatively high:</p>
<pre><code>y = st_as_sf(dem, as_points = TRUE) y$lat = st_coordinates(st_transform(y, 4326))[,2] y = st_rasterize(y[, "lat"], dem) y[y &lt; 31] = NA y[!is.na(y)] = 1 y = st_as_sf(y, merge = TRUE) dem = dem[y]</code></pre>
<p>Next, we <em>extract</em> the elevation values (Section <a href="https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-points-single-band">10.7.2</a>):</p>
<pre><code>rainfall = st_join(rainfall, st_as_sf(dem))</code></pre>
<p>and subset those stations that coincide with the raster:</p>
<pre><code>rainfall = rainfall[!is.na(rainfall$elev_1km), ]</code></pre>
<p>Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:elevation-rainfall">12.10</a> shows the <code>dem</code> elevation raster and the <code>rainfall</code> point layer:</p>
<pre><code>plot(dem, breaks = "equal", col = terrain.colors(11), reset = FALSE) plot(st_geometry(rainfall), add = TRUE)</code></pre>
<p>Figure 12.10: Rainfall data points and elevation raster</p>
</section>
</section>
<section id="inverse-distance-weighted-interpolation" class="level2" data-number="17.3">
<h2 data-number="17.3" class="anchored" data-anchor-id="inverse-distance-weighted-interpolation"><span class="header-section-number">17.3</span> Inverse Distance Weighted interpolation</h2>
<section id="the-gstat-object" class="level3" data-number="17.3.1">
<h3 data-number="17.3.1" class="anchored" data-anchor-id="the-gstat-object"><span class="header-section-number">17.3.1</span> The <code>gstat</code> object</h3>
<p>To interpolate, we first need to create an object of class <code>gstat</code>, using a function of the same name: <code>gstat</code>. A <code>gstat</code> object contains all necessary information to conduct spatial interpolation, namely:</p>
<ul>
<li><p>The <strong>model</strong> definition</p></li>
<li><p>The calibration <strong>data</strong></p></li>
</ul>
<p>Based on its arguments, the <code>gstat</code> function "understands" what type of interpolation model we want to use:</p>
<ul>
<li><p>No variogram model → <strong>IDW</strong></p></li>
<li><p>Variogram model, no covariates → <strong>Ordinary Kriging</strong></p></li>
<li><p>Variogram model, with covariates → <strong>Universal Kriging</strong></p></li>
</ul>
<p>The complete decision tree of <code>gstat</code>, including several additional methods which we are not going to use, is shown in Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:gstat-decision-tree">12.11</a>.</p>
<p>Figure 12.11: <code>gstat</code> predict methods (Applied Spatial Data Analysis with R, 2013)</p>
<p>We are going to use three parameters of the <code>gstat</code> function:</p>
<ul>
<li><p><code>formula</code>—The prediction <strong>"formula"</strong> specifying the dependent and the independent variables (covariates)</p></li>
<li><p><code>data</code>—The calibration <strong>data</strong></p></li>
<li><p><code>model</code>—The <strong>variogram</strong> model</p></li>
</ul>
<p>Keep in mind that we need to specify parameter names, because these three parameters are not the first three in the <code>gstat</code> function definition.</p>
<p>For example, to interpolate using the <strong>IDW</strong> method we create the following <code>gstat</code> object, specifying just the <code>formula</code> (Section <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#working-with-formula-objects">12.2.2</a> below) and <code>data</code>:</p>
<pre><code>library(gstat) g = gstat(formula = annual ~ 1, data = rainfall)</code></pre>
</section>
<section id="working-with-formula-objects" class="level3" data-number="17.3.2">
<h3 data-number="17.3.2" class="anchored" data-anchor-id="working-with-formula-objects"><span class="header-section-number">17.3.2</span> Working with <code>formula</code> objects</h3>
<p>Im R, <code>formula</code> objects are used to specify <em>relation</em> between objects, in particular—the role of different data columns in statistical models. A <code>formula</code> object is created using the <code>~</code> operator, which separates names of <strong>dependent</strong> variables (to the left of the <code>~</code> symbol) and <strong>independent</strong> variables (to the right of the <code>~</code> symbol). Writing <code>1</code> to the right of the <code>~</code> symbol, as in <code>~ 1</code>, means that there are no independent variables<sup><a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fn39">39</a></sup>.</p>
<p>For example, in the following expression we create a <code>formula</code> object named <code>f</code>:</p>
<pre><code>f = annual ~ 1 f ## annual ~ 1</code></pre>
<p>Checking the class shows that <code>f</code> is indeed a <code>formula</code> object:</p>
<pre><code>class(f) ## [1] "formula"</code></pre>
<p>We can also convert <code>character</code> values to <code>formula</code> using the <code>as.formula</code> function. For example:</p>
<pre><code>f = as.formula("annual ~ 1") class(f) ## [1] "formula"</code></pre>
<p>The <code>as.formula</code> function is particularly useful when we want to construct different formulas as part of a <code>for</code> loop (Section <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#monthly-rainfall-example">12.3.3</a>).</p>
</section>
<section id="making-predictions" class="level3" data-number="17.3.3">
<h3 data-number="17.3.3" class="anchored" data-anchor-id="making-predictions"><span class="header-section-number">17.3.3</span> Making predictions</h3>
<p>Now that our model is defined, we can use the <code>predict</code> function to actually interpolate, i.e., to calculate predicted values. The <code>predict</code> function accepts:</p>
<ul>
<li><p>A <strong>raster</strong>—<code>stars</code> object, such as <code>dem</code></p></li>
<li><p>A <strong>model</strong>—<code>gstat</code> object, such as <code>g</code></p></li>
</ul>
<p>The raster serves for two purposes:</p>
<ul>
<li><p>Specifying the <strong>locations</strong> where we want to make predictions (in all methods)</p></li>
<li><p>Specifying <strong>covariate</strong> values (in Universal Kriging only)</p></li>
</ul>
<p>For example, the following expression interpolates <code>annual</code> values according to the model defined in <code>g</code> and the raster template defined in <code>dem</code>:</p>
<pre><code>z = predict(g, dem) ## [inverse distance weighted interpolation]</code></pre>
<p>The resulting <code>stars</code> object has two attributes:</p>
<ul>
<li><p><code>var1.pred</code>—the predicted values</p></li>
<li><p><code>var1.var</code>—the variance (for Kriging only)</p></li>
</ul>
<p>For example:</p>
<pre><code>z ## stars object with 2 dimensions and 2 attributes ## attribute(s): ##    var1.pred        var1.var      ##  Min.   : 42.85   Min.   : NA     ##  1st Qu.:356.01   1st Qu.: NA     ##  Median :495.20   Median : NA     ##  Mean   :466.49   Mean   :NaN     ##  3rd Qu.:552.16   3rd Qu.: NA     ##  Max.   :946.31   Max.   : NA     ##  NA's   :20108    NA's   :39933   ## dimension(s): ##   from  to  offset delta                       refsys point values x/y ## x    1 153  616965  1000 +proj=utm +zone=36 +datum...    NA   NULL [x] ## y    1 261 3691819 -1000 +proj=utm +zone=36 +datum...    NA   NULL [y]</code></pre>
<p>We can subset just the first attribute and rename it to <code>"annual"</code>:</p>
<pre><code>z = z["var1.pred",,] names(z) = "annual"</code></pre>
<p>The interpolated annual rainfall raster, using IDW, is shown in Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-idw">12.12</a>:</p>
<pre><code>b = seq(0, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, "Spectral"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)</code></pre>
<p>Figure 12.12: Predicted annual rainfall using Inverse Distance Weighted (IDW) interpolation</p>
</section>
</section>
<section id="ordinary-kriging" class="level2" data-number="17.4">
<h2 data-number="17.4" class="anchored" data-anchor-id="ordinary-kriging"><span class="header-section-number">17.4</span> Ordinary Kriging</h2>
<section id="annual-rainfall-example" class="level3" data-number="17.4.1">
<h3 data-number="17.4.1" class="anchored" data-anchor-id="annual-rainfall-example"><span class="header-section-number">17.4.1</span> Annual rainfall example</h3>
<p>Kriging methods require a <strong>variogram model</strong>. The variogram model is an objective way to quantify the autocorrelation pattern in the data, and assign weights accordingly when making predictions (Section <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#the-weighted-average-principle">12.1.2</a>).</p>
<p>As a first step, we can calculate and examine the <strong>empirical variogram</strong> using the <code>variogram</code> function. The function requires two arguments:</p>
<ul>
<li><p><code>formula</code>—Specifies the <strong>dependent variable</strong> and the <strong>covariates</strong>, just like in <code>gstat</code></p></li>
<li><p><code>data</code>—The <strong>point</strong> layer with the dependent variable and covariates as point attributes</p></li>
</ul>
<p>For example, the following expression calculates the empirical variogram of <code>annual</code>, with no covariates:</p>
<pre><code>v_emp_ok = variogram(annual ~ 1, rainfall)</code></pre>
<p>Using <code>plot</code> to examine it we can examine the variogram (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram">12.13</a>):</p>
<pre><code>plot(v_emp_ok)</code></pre>
<p>Figure 12.13: Empirical variogram</p>
<p>There are several ways to fit a <strong>variogram model</strong> to an empirical variogram. We will use the simplest one—<em>automatic</em> fitting using function <code>autofitVariogram</code> from package <code>automap</code>:</p>
<pre><code>library(automap) v_mod_ok = autofitVariogram(annual ~ 1, as(rainfall, "Spatial"))</code></pre>
<p>The function chooses the best fitting type of model, and also fine tunes its parameters. (Use <code>show.vgms()</code> to display variogram model types.) Note that the <code>autofitVariogram</code> function does not work on <code>sf</code> objects, which is why we convert the object to a <code>SpatialPointsDataFrame</code> (package <code>sp</code>).</p>
<p>The fitted model can be plotted with <code>plot</code> (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram-model">12.14</a>):</p>
<pre><code>plot(v_mod_ok)</code></pre>
<p>Figure 12.14: Variogram model</p>
<p>The resulting object is actually a <code>list</code> with several components, including the empirical variogram and the fitted variogram model. The <code>$var_model</code> component of the resulting object contains the actual model:</p>
<pre><code>v_mod_ok$var_model ##   model      psill    range kappa ## 1   Nug   451.9177     0.00     0 ## 2   Ste 23223.8370 34604.87     2</code></pre>
<p>The variogram model can then be passed to the <code>gstat</code> function, and we can carry on with the Ordinary Kriging interpolation:</p>
<pre><code>g = gstat(formula = annual ~ 1, model = v_mod_ok$var_model, data = rainfall) z = predict(g, dem) ## [using ordinary kriging]</code></pre>
<p>Again, we will subset the predicted values attribute and rename it:</p>
<pre><code>z = z["var1.pred",,] names(z) = "annual"</code></pre>
<p>The Ordinary Kriging predictions are shown in Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-ok">12.15</a>:</p>
<pre><code>b = seq(0, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, "Spectral"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)</code></pre>
<p>Figure 12.15: Predicted annual rainfall using Ordinary Kriging</p>
</section>
<section id="elevation-example" class="level3" data-number="17.4.2">
<h3 data-number="17.4.2" class="anchored" data-anchor-id="elevation-example"><span class="header-section-number">17.4.2</span> Elevation example</h3>
<p>Another example: suppose that we did not have a DEM for Israel, but only the elevation measurements at the meteorological stations. How can we produce an elevation raster using Ordinary Kriging?</p>
<p>First, we prepare the <code>gstat</code> object:</p>
<pre><code>v = autofitVariogram(altitude ~ 1, as(rainfall, "Spatial")) g = gstat(formula = altitude ~ 1, model = v$var_model, data = rainfall)</code></pre>
<p>Then, we interpolate:</p>
<pre><code>z = predict(g, dem) ## [using ordinary kriging] z = z["var1.pred",,] names(z) = "elevation"</code></pre>
<p>The predicted elevation raster is shown in Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:elevation-ok">12.16</a>:</p>
<pre><code>b = seq(-500, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, "Spectral"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)</code></pre>
<p>Figure 12.16: Ordinary Kriging prediction of elevation</p>
</section>
<section id="monthly-rainfall-example" class="level3" data-number="17.4.3">
<h3 data-number="17.4.3" class="anchored" data-anchor-id="monthly-rainfall-example"><span class="header-section-number">17.4.3</span> Monthly rainfall example</h3>
<p>In the next example we use kriging inside a <code>for</code> loop, to make a series of predictions for different variables. Specifically, we will use Ordinary Kriging to predict <em>monthly rainfall</em>, i.e., <code>sep</code> through <code>may</code> columns in the <code>rainfall</code> layer.</p>
<p>In each <code>for</code> loop "round," the formula is going to be re-defined according to the current month <code>i</code>. For example:</p>
<pre><code>i = "may" as.formula(paste0(i, " ~ 1")) ## may ~ 1</code></pre>
<p>First, we set up a vector with the column names of the variables we wish to interpolate, and a <code>list</code> where we "collect" the results:</p>
<pre><code>m = c("sep", "oct", "nov", "dec", "jan", "feb", "mar", "apr", "may") result = list()</code></pre>
<p>Second, we specify the <code>for</code> loop, as follows:</p>
<pre><code>for(i in m) {   f = as.formula(paste0(i, " ~ 1"))   v = autofitVariogram(f, as(rainfall, "Spatial"))   g = gstat(formula = f, model = v$var_model, data = rainfall)   z = predict(g, dem)   z = z["var1.pred",,]   result[[i]] = z } ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging]</code></pre>
<p>Finally, we combine the <code>list</code> of results per month into a single multi-band raster, using <code>do.call</code> and <code>c</code> (Section <a href="https://geobgu.xyz/r-2021/processing-spatio-temporal-data.html#aggregating-time-periods">11.3.2</a>):</p>
<pre><code>result$along = 3 result = do.call(c, result)</code></pre>
<p>The interpolated montly rainfall amounts are shown in Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:kriging-monthly-rainfall">12.17</a>:</p>
<pre><code>plot(result, breaks = "equal", col = hcl.colors(11, "Spectral"), key.pos = 4)</code></pre>
<p>Figure 12.17: Monthly rainfall predictions using Ordinary Kriging</p>
</section>
</section>
<section id="universal-kriging" class="level2" data-number="17.5">
<h2 data-number="17.5" class="anchored" data-anchor-id="universal-kriging"><span class="header-section-number">17.5</span> Universal Kriging</h2>
<p><strong>Universal Kriging</strong> interpolation uses a model with one or more independent variables, i.e., covariates. The covariates need to be known for both:</p>
<ul>
<li><p>The <strong>point layer</strong>, as an attribute such as <code>elev_1km</code> in <code>rainfall</code></p></li>
<li><p>The <strong>predicted locations</strong>, as raster values such as <code>dem</code> values</p></li>
</ul>
<p>The <code>formula</code> now specifies the name(s) of the covariate(s) to the right of the <code>~</code> symbol, separated by <code>+</code> if there are more than one. Also, we are using a subset of <code>rainfall</code> where <code>elev_1km</code> values were present:</p>
<pre><code>v_emp_uk = variogram(annual ~ elev_1km, rainfall) v_mod_uk = autofitVariogram(annual ~ elev_1km, as(rainfall, "Spatial"))</code></pre>
<p>Comparing the Ordinary Kriging and Universal Kriging variogram models (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram-models-ok-uk">12.18</a>):</p>
<pre><code>plot(v_emp_ok, model = v_mod_ok$var_model, ylim = c(0, 25000), main = "OK") plot(v_emp_uk, model = v_mod_uk$var_model, ylim = c(0, 25000), main = "UK")</code></pre>
<p>Figure 12.18: OK and UK variogram models</p>
<p>Next we create a <code>gstat</code> object, where the <code>formula</code> contains the covariate and the corresponding variogram model:</p>
<pre><code>g = gstat(formula = annual ~ elev_1km, model = v_mod_uk$var_model, data = rainfall)</code></pre>
<p>Remember that all of the variables that appear in the <code>formula</code> need to be present in the <code>data</code>. In this case we have two variables: a dependent variable (<code>annual</code>) and an independent variable (<code>elev_1km</code>).</p>
<p>Now we can make predictions:</p>
<pre><code>z = predict(g, dem) ## [using universal kriging]</code></pre>
<p>and then subset and rename:</p>
<pre><code>z = z["var1.pred",,] names(z) = "annual"</code></pre>
<p>Universal Kriging predictions are shown in Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-uk">12.19</a>:</p>
<pre><code>b = seq(0, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, "Spectral"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)</code></pre>
<p>Figure 12.19: Predicted annual rainfall using Universal Kriging</p>
</section>
<section id="cross-validation" class="level2" data-number="17.6">
<h2 data-number="17.6" class="anchored" data-anchor-id="cross-validation"><span class="header-section-number">17.6</span> Cross-validation</h2>
<p>In Sections <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#inverse-distance-weighted-interpolation">12.2</a>–<a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#universal-kriging">12.4</a>, we have calculated annual rainfall surfaces using three different methods: IDW, Ordinary Kriging and Universal Kriging. Although it is useful to examine and compare the results graphically (Figures <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-idw">12.12</a>, <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-ok">12.15</a>, and <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-uk">12.19</a>), we also need an objective way to evaluate interolation <em>accuracy</em>. That way, we can objectively choose the most accurate method among the various interpolation methods there are.</p>
<p>Plainly speaking, to evaluate prediction accuracy we need to compare the predicted values with measured data in the same location. Since measured data are often sparse and expensive to produce, it makes little sense to collect more data merely for the sake of accuracy assessment. Instead, the available data are usually <em>split</em> to two parst, called training and test data. The training data are used to fit the model, while the test data are used to calculate prediction accuracy. The procedure is called <strong>cross validation</strong>. A specific, commonly used, type of cross validation is <strong>Leave-One-Out Cross Validation</strong> where all observations consecutively take the role of test data while the remaning observations take the role of training data. The separation of training and test data is important because evaluating a model based on the same data used to fit it gives the model an "unfair" advantage and therefore overestimates accuracy.</p>
<p>In Leave-One-Out Cross Validation we:</p>
<ul>
<li><p><strong>Take out</strong> one point out of the calibration data</p></li>
<li><p>Make a <strong>prediction</strong> for that point</p></li>
<li><p><strong>Repeat</strong> for all points</p></li>
</ul>
<p>In the end, what we get is a table with an <em>observed</em> value and a <em>predicted</em> value for all points.</p>
<p>We can run Leave-One-Out Cross Validation using the <code>gstat.cv</code> function, which accepts a <code>gstat</code> object:</p>
<pre><code>cv = gstat.cv(g)</code></pre>
<p>The <code>gstat.cv</code> function returns an object of class <code>SpatialPointsDataFrame</code> (package <code>sp</code>), which we can convert to an <code>sf</code> object with <code>st_as_sf</code>:</p>
<pre><code>cv = st_as_sf(cv) cv ## Simple feature collection with 160 features and 6 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 629301.4 ymin: 3435503 xmax: 761589.2 ymax: 3681163 ## CRS:           NA ## First 10 features: ##    var1.pred var1.var observed    residual       zscore fold ## 1   632.4635 951.6388    582.8 -49.6635206 -1.609909413    1 ## 2   614.6876 915.2690    608.5  -6.1876076 -0.204525930    2 ## 3   598.0584 907.7003    614.7  16.6415723  0.552361147    3 ## 4   609.5275 774.8052    562.7 -46.8274602 -1.682303431    4 ## 5   701.0174 913.6664    682.8 -18.2174496 -0.602689676    5 ## 6   610.4985 740.2553    705.5  95.0014929  3.491722024    6 ## 7   645.4771 824.3927    610.4 -35.0771011 -1.221677615    7 ## 8   581.9809 976.5117    583.3   1.3190893  0.042211954    8 ## 9   654.7017 705.9952    709.8  55.0983188  2.073659677    9 ## 10  654.6546 706.8918    654.8   0.1454226  0.005469598   10 ##                    geometry ## 1  POINT (697119.1 3656748) ## 2  POINT (696509.3 3652434) ## 3  POINT (696541.7 3641332) ## 4  POINT (697875.3 3630156) ## 5  POINT (689553.7 3626282) ## 6  POINT (694694.5 3624388) ## 7  POINT (686489.5 3619716) ## 8  POINT (683148.4 3616846) ## 9  POINT (696489.3 3610221) ## 10 POINT (693025.1 3608449)</code></pre>
<p>The result of <code>gstat.cv</code> has the following attributes:</p>
<ul>
<li><p><code>var1.pred</code>—Predicted value</p></li>
<li><p><code>var1.var</code>—Variance (only for Kriging)</p></li>
<li><p><code>observed</code>—Observed value</p></li>
<li><p><code>residual</code>—Observed-Predicted</p></li>
<li><p><code>zscore</code>—Z-score (only for Kriging)</p></li>
<li><p><code>fold</code>—Cross-validation ID</p></li>
</ul>
<p>A <strong>bubble plot</strong> is convenient to examine the residuals, since it shows positive and negative values in different color (Figure <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:bubble-plot">12.20</a>):</p>
<pre><code>bubble(as(cv[, "residual"], "Spatial"))</code></pre>
<p>Figure 12.20: Cross-validation residuals</p>
<p>Using the "predicted" and "observed" columns we can calculate prediction accuracy indices, such as the <strong>Root Mean Square Error (RMSE)</strong> (Equation <a href="https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:rmse">(12.4)</a>):</p>
<p><u>RMSE=√∑ni=1(predi−obsi)2n(12.4)(12.4)����=∑�=1�(�����−����)2�</u></p>
<p>where predi����� and obsi���� are <em>predicted</em> and <em>observed</em> values for point i�, respectively.</p>
<p>For example:</p>
<pre><code>sqrt(sum((cv$var1.pred - cv$observed)^2) / nrow(cv)) ## [1] 36.21741</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ch11.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Processing spatio-temporal data</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ch13.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">High Frequency Data</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>